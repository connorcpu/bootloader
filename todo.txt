restructure
makefile upgrade (learn make)
setup/generate standard library for cross-compliler
complete filesystem 
   - actually read FAT
   - write loadClusterChain() function with FAT info
   - rewrite openFile() to search subdirectories until file is found, then load the cluster chain
propper memory managment DONE
terminal
VESA (map that high address to something waaaaay lower) DONE
elf execution 
propperly link the kernel so we can link against it for program execution (not how that works you bozo)
implement mmap DONE



dependency tree:

generate stdlib
restructure files 
makefile upgrade
propper kernel linking
memory DONE
   - VESA DONE
   - elf execution
      - split stage 2 and kernel 
      - relocate kernel to higher half (just load and link it at a different address)
      - we might be able to get away with programs under 32KiB but we really really shouldn't
   - filesystem (could be treated independently)

   the way memory works is the upper part of the address is translated into a page using the hyrarchical page tables. then once the page is found, the physical address is read from the page table entry

   (32 bit)
   so to map virtual 0xc0000000(8 digits) to physical 0x100000(6 digits), the upper 10 bits, 0xC0, 00b(2 digits hex, 2 bin) refer to index of the page dir entry, in bin its, 1100000000(10 digits), the next 10 specify the page table entry, so thats 00b, 0x00 or the first one.
   then that page table entry is read and the alocated bits are read to find the implicated physical address.

   having multiple page table entries with 0x0 in their adress creates the effect that multiple programs can use 0x0 as their adress base.
   (where do they get the bloody page table bits from) (not out of the woods yet)
   (on osdev paging article, read process context identifier, might be the awnser)

terminal
